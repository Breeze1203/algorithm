package main

/*
Problem Description
给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null

解题思路：
方法一：哈希表 (Hash Set)
遍历链表 A： 遍历第一个链表 headA，并将每个节点的内存地址存储到一个哈希表中。
遍历链表 B： 遍历第二个链表 headB。对于 headB 中的每个节点，检查其内存地址是否已经存在于哈希表中。
找到交点： 如果在哈希表中找到了 headB 中某个节点的地址，那么这个节点就是两个链表相交的起始节点。
无交点： 如果遍历完 headB 仍未在哈希表中找到任何节点，则说明两个链表不相交，返回 null。

好的，我们来解决这个问题：找出并返回两个单链表相交的起始节点。如果两个链表没有交点，则返回 null。

问题描述：

给定两个单链表的头节点 headA 和 headB，如果它们相交，则返回相交的起始节点；否则，返回 null。

重要概念：

相交的定义： 两个链表相交指的是，从某个节点开始，它们的 Next 指针指向了同一个节点，从而后续所有节点都完全相同。也就是说，相交不是指节点的值相同，而是指节点的内存地址相同。
Y 型结构： 如果两个链表相交，它们的结构会像一个 "Y" 字形。
解题思路：

有几种常见的方法可以解决这个问题：

方法一：哈希表 (Hash Set)
遍历链表 A： 遍历第一个链表 headA，并将每个节点的内存地址存储到一个哈希表中。
遍历链表 B： 遍历第二个链表 headB。对于 headB 中的每个节点，检查其内存地址是否已经存在于哈希表中。
找到交点： 如果在哈希表中找到了 headB 中某个节点的地址，那么这个节点就是两个链表相交的起始节点。
无交点： 如果遍历完 headB 仍未在哈希表中找到任何节点，则说明两个链表不相交，返回 null。
优点： 思路简单直接。
缺点： 需要额外的空间来存储哈希表，空间复杂度为 O(m) 或 O(n)，其中 m 和 n 分别是两个链表的长度。

方法二：双指针法 (优雅且空间复杂度更优)
初始化指针： 创建两个指针，pA 指向 headA，pB 指向 headB。
同步遍历： 同时向前移动 pA 和 pB。
指针重定向：
如果 pA 到达了链表 A 的末尾 (即 pA == nil)，则将 pA 重定向到链表 B 的头节点 (headB)。
如果 pB 到达了链表 B 的末尾 (即 pB == nil)，则将 pB 重定向到链表 A 的头节点 (headA)。
判断相交：
如果两个链表相交，那么 pA 和 pB 最终会在相交节点处相遇。
如果两个链表不相交，那么 pA 和 pB 会在分别遍历完两个链表（即 pA 走过了 A+B 的长度，pB 走过了 B+A 的长度）后同时变为 nil，此时它们依然相等 (pA == pB == nil)。
循环条件： 循环继续的条件是 pA != pB。当它们相等时，循环终止。此时的 pA (或 pB) 就是相交节点；如果它们不相交，则此时 pA (和 pB) 均为 nil
*/

func getIntersectionNode(headA *ListNode, headB *ListNode) *ListNode {
	if headA == nil || headB == nil {
		return nil
	}
	pA, pB := headA, headB
	for pA != pB {
		// 如果 pA 到达链表 A 的末尾，则将其重定向到链表 B 的头
		// 否则，pA 向前移动一步
		if pA == nil {
			pA = headB
		} else {
			pA = pA.Next
		}
		// 如果 pB 到达链表 B 的末尾，则将其重定向到链表 A 的头
		// 否则，pB 向前移动一步
		if pB == nil {
			pB = headA
		} else {
			pB = pB.Next
		}
	}

	// 当循环结束时，pA (或 pB) 要么是相交节点，要么是 nil (如果不相交)
	return pA
}
