package main

/*
Problem Description
给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的 字母异位词(字母异位词是通过重新排列不同单词或短语的字母而形成的单词或短语
，并使用所有原字母一次 ---->字母种类和每种字母的数量都完全一样，只是排列顺序可能不一样)

思路：
第一道关卡：长度检查
如果两个字符串的长度都不一样，那它们肯定不可能是字母异位词。比如 "abc" (长度3) 和 "aabbcc" (长度6) 肯定不行。直接返回 false。

第二道关卡：统计字母频率
如果长度相同，我们就需要比较它们包含的字母种类和数量是否完全一致。
一个常见且有效的方法是使用一个计数器（比如一个哈希表/字典，或者一个固定大小的数组，如果只考虑小写英文字母的话）来记录每个字符串中每个字母出现的次数。
方法一：分别统计再比较
创建一个计数器 s_counts 来统计字符串 s 中每个字符的出现次数。
创建另一个计数器 t_counts 来统计字符串 t 中每个字符的出现次数。
最后，比较这两个计数器是否完全相同（即对于每一个字符，它在 s_counts 中的计数和在 t_counts 中的计数都一样）。
方法二：增减相抵法（更优）
创建一个计数器（比如一个大小为 26 的数组，对应 'a' 到 'z'，如果只考虑小写英文字母）。
遍历字符串 s：对于 s 中的每个字符，在计数器中对应位置的值增加 1。
遍历字符串 t：对于 t 中的每个字符，在计数器中对应位置的值减少 1。
如果 s 和 t 是字母异位词，那么最终计数器中所有位置的值都应该变回 0。如果有任何一个位置的值不是 0，说明它们的字母组成不同
*/
func isAnagram(s string, t string) bool {
	// 第一道关卡：长度检查
	if len(s) != len(t) {
		return false
	}
	// 第二道关卡：统计字母频率 (使用增减相抵法)
	// 假设字符串只包含小写英文字母。
	// 则需要使用 map[rune]int 或者更大的数组。
	charCount := make(map[rune]int) // 使用 map 可以处理更广泛的字符集
	// 统计字符串 s 中每个字符的频率
	for _, charS := range s {
		charCount[charS]++
	}
	// 减去字符串 t 中每个字符的频率
	for _, charT := range t {
		charCount[charT]--
	}

	// 最终判断：检查 charCount 中的所有计数是否都为 0
	for _, count := range charCount {
		if count != 0 {
			return false
		}
	}

	return true
}
